<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>MiniState Declarative Approach</title>

  <!-- Include DaisyUI and Tailwind CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/daisyui@2.51.5/dist/full.css">
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- MiniState Library -->
  <script>
    const MiniState = (() => {
      const state = {};
      const watchers = {};
      const predefinedStates = {};

      const allowedWatchProperties = [
        "textContent",
        "innerHTML",
        "value",
        "click",
        "input",
        "change",
        "submit",
        "className",
        "classList",
        "selected",
        "disabled",
        "fetch"
      ];

      const elements = {};
      let _predefinedStateScheduled = false;

      const getElement = (componentId) => {
        if (!elements[componentId]) {
          elements[componentId] = document.querySelector(`#${componentId}`);
        }
        return elements[componentId];
      };

      return {
        init(externalStates) {
          Object.assign(predefinedStates, externalStates);
        },

        watch(componentId, property, callback) {
          if (!allowedWatchProperties.includes(property)) {
            console.error(`Property '${property}' is not allowed.`);
            return;
          }
          const stateKey = `${componentId}.${property}`;
          if (!watchers[stateKey]) watchers[stateKey] = [];
          watchers[stateKey].push(callback);

          // Set up event listeners for user interactions
          if (["click", "input", "change", "submit"].includes(property)) {
            const element = getElement(componentId);
            if (element) {
              element.addEventListener(property, () => {
                // Call the callback directly
                callback("triggered");
              });
            }
          }
        },

        _notify(componentId, property, newValue) {
          const stateKey = `${componentId}.${property}`;
          // Notify watchers
          if (watchers[stateKey]) {
            watchers[stateKey].forEach(callback => callback(newValue));
          }

          // Update the DOM element if applicable
          const element = getElement(componentId);

          // Properties to skip when updating DOM elements
          const skipDomUpdateProperties = ["click", "input", "change", "submit", "fetch"];

          if (element && !skipDomUpdateProperties.includes(property)) {
            if (property === "classList") {
              // Handle classList updates
              element.classList.value = newValue;
            } else {
              element[property] = newValue;
            }
          }
        },

        requestLocalStateChange(componentId, property, newValue) {
          if (!allowedWatchProperties.includes(property)) {
            console.error(`Property '${property}' is not allowed.`);
            return;
          }
          const stateKey = `${componentId}.${property}`;
          let currentValue = state[stateKey];

          // Handle toggle functionality
          if (newValue === "toggle") {
            if (currentValue === "true") {
              newValue = "false";
            } else if (currentValue === "false" || currentValue === undefined) {
              newValue = "true";
            } else {
              // For non-boolean values, toggle between empty string and the provided value
              newValue = currentValue === "" ? "hidden" : "";
            }
          }

          newValue = String(newValue);

          if (currentValue !== newValue) {
            state[stateKey] = newValue;
            this._notify(componentId, property, newValue);

            // Schedule predefined state check
            if (!_predefinedStateScheduled) {
              _predefinedStateScheduled = true;
              Promise.resolve().then(() => {
                this._checkPredefinedStates();
                _predefinedStateScheduled = false;
              });
            }
          }
        },

        _checkPredefinedStates() {
          for (const [stateName, stateConditions] of Object.entries(predefinedStates)) {
            let match = true;
            for (const [key, value] of Object.entries(stateConditions)) {
              if (state[key] !== value) {
                match = false;
                break;
              }
            }
            if (match) {
              // Transitioned to a predefined state
              console.log(`Transitioned to state '${stateName}':`, stateConditions);
              break; // Apply only the first matching state
            }
          }
        }
      };
    })();

    // Initialize MiniState with predefined states
    MiniState.init({
      "SIDEBAR_HIDDEN": {
        "toggleButton.value": "false"
      },
      "SIDEBAR_VISIBLE": {
        "toggleButton.value": "true"
      }
    });
  </script>
</head>
<body class="flex">

  <!-- Sidebar Component -->
  <div id="sidebarComponent" class="bg-neutral w-64 h-full fixed top-0 left-0 flex flex-col justify-between transition-transform duration-300 ease-in-out z-10 hidden">
    <!-- Sidebar content -->
    <div class="h-16 flex items-center justify-between px-4">
      <button class="toggleSidebarButton text-accent" aria-label="Toggle Sidebar">â˜°</button>
    </div>

    <nav class="flex-1 p-4">
      <ul class="menu w-full">
        <li>Sidebar Entry</li>
      </ul>
    </nav>
  </div>

  <!-- Button Component -->
  <div id="buttonComponent" class="flex flex-col justify-center items-center w-full h-full">
    <button id="toggleButton" class="btn btn-primary">Show Sidebar</button>

    <script>
      // Button Component Script

      // Initialize the 'value' state of toggleButton to 'false'
      MiniState.requestLocalStateChange("toggleButton", "value", "false");

      // Watch for click events on the toggleButton
      MiniState.watch("toggleButton", "click", () => {
        // Request to toggle the 'value' of toggleButton
        MiniState.requestLocalStateChange("toggleButton", "value", "toggle");
      });

      // Watch for changes in its own 'value' to update the button text
      MiniState.watch("toggleButton", "value", (newValue) => {
        const buttonText = newValue === "true" ? "Hide Sidebar" : "Show Sidebar";
        MiniState.requestLocalStateChange("toggleButton", "textContent", buttonText);
      });
    </script>
  </div>

  <!-- Sidebar Component Script -->
  <script>
    // Watch for changes in 'toggleButton.value'
    MiniState.watch("toggleButton", "value", (newValue) => {
      // Based on the new value, update the sidebar's classList
      if (newValue === "true") {
        // Remove 'hidden' class to show the sidebar
        MiniState.requestLocalStateChange("sidebarComponent", "classList", "bg-neutral w-64 h-full fixed top-0 left-0 flex flex-col justify-between transition-transform duration-300 ease-in-out z-10");
      } else {
        // Add 'hidden' class to hide the sidebar
        MiniState.requestLocalStateChange("sidebarComponent", "classList", "bg-neutral w-64 h-full fixed top-0 left-0 flex flex-col justify-between transition-transform duration-300 ease-in-out z-10 hidden");
      }
    });
  </script>

  <!-- Example Component for Async Operation -->
  <div id="exampleComponent">
    <!-- Content will be loaded asynchronously -->
    <script>
      // Example Component Script

      // Watch for 'fetch' property to trigger async operation
      MiniState.watch("exampleComponent", "fetch", async () => {
        MiniState.requestLocalStateChange("exampleComponent", "textContent", "Loading...");
        try {
          const response = await fetch('https://jsonplaceholder.typicode.com/todos/1');
          const data = await response.json();
          MiniState.requestLocalStateChange("exampleComponent", "textContent", data.title);
        } catch (error) {
          MiniState.requestLocalStateChange("exampleComponent", "textContent", "Error loading data");
        }
      });

      // Trigger the fetch operation
      MiniState.requestLocalStateChange("exampleComponent", "fetch", "start");
    </script>
  </div>

</body>
</html>
