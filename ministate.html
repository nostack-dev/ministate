<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>MiniState Declarative Example with Sidebar and Fetch</title>

  <!-- Include DaisyUI and Tailwind CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/daisyui@2.51.5/dist/full.css">
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- MiniState Library -->
  <script>
    const MiniState = (() => {
      const state = {};
      const watchers = {};
      const predefinedStates = {};

      const allowedWatchProperties = [
        "textContent",
        "innerHTML",
        "value",
        "click",
        "input",
        "change",
        "submit",
        "className",
        "classList",
        "selected",
        "disabled",
        "fetch",
        "url"
      ];

      const elements = {};
      let _predefinedStateScheduled = false;
      let _currentStateName = null; // Variable to track the current state

      const getElement = (componentId) => {
        if (!elements[componentId]) {
          elements[componentId] = document.querySelector(`#${componentId}`);
        }
        return elements[componentId];
      };

      return {
        init(externalStates) {
          Object.assign(predefinedStates, externalStates);
        },

        watch(componentId, property, ...args) {
          if (!allowedWatchProperties.includes(property)) {
            console.error(`Property '${property}' is not allowed.`);
            return;
          }
          const callback = args[args.length - 1];
          const params = args.slice(0, -1); // Additional parameters

          const stateKey = `${componentId}.${property}`;
          if (!watchers[stateKey]) watchers[stateKey] = [];
          watchers[stateKey].push({ callback, params });

          // Set up event listeners for user interactions
          if (["click", "input", "change", "submit"].includes(property)) {
            const element = getElement(componentId);
            if (element) {
              element.addEventListener(property, () => {
                // Call the callback directly
                callback("triggered", ...params);
              });
            }
          }
        },

        _notify(componentId, property, newValue) {
          const stateKey = `${componentId}.${property}`;
          // Notify watchers
          if (watchers[stateKey]) {
            watchers[stateKey].forEach(({ callback, params }) => {
              callback(newValue, ...params);
            });
          }

          // Update the DOM element if applicable
          const element = getElement(componentId);

          // Properties to skip when updating DOM elements
          const skipDomUpdateProperties = ["click", "input", "change", "submit", "fetch", "url"];

          if (element && !skipDomUpdateProperties.includes(property)) {
            if (property === "classList") {
              // Handle classList updates
              element.classList.value = newValue;
            } else {
              element[property] = newValue;
            }
          }
        },

        requestLocalStateChange(componentId, property, newValue) {
          if (!allowedWatchProperties.includes(property)) {
            console.error(`Property '${property}' is not allowed.`);
            return;
          }
          const stateKey = `${componentId}.${property}`;
          let currentValue = state[stateKey];

          // Handle toggle functionality
          if (newValue === "toggle") {
            if (currentValue === "true") {
              newValue = "false";
            } else if (currentValue === "false" || currentValue === undefined) {
              newValue = "true";
            } else {
              // For non-boolean values, toggle between empty string and the provided value
              newValue = currentValue === "" ? "hidden" : "";
            }
          }

          newValue = String(newValue);

          if (currentValue !== newValue) {
            state[stateKey] = newValue;
            this._notify(componentId, property, newValue);

            // Schedule predefined state check
            if (!_predefinedStateScheduled) {
              _predefinedStateScheduled = true;
              Promise.resolve().then(() => {
                this._checkPredefinedStates();
                _predefinedStateScheduled = false;
              });
            }
          }
        },

        _checkPredefinedStates() {
          for (const [stateName, stateConditions] of Object.entries(predefinedStates)) {
            let match = true;
            for (const [key, value] of Object.entries(stateConditions)) {
              if (state[key] !== value) {
                match = false;
                break;
              }
            }
            if (match) {
              // Check if the state has changed
              if (_currentStateName !== stateName) {
                _currentStateName = stateName;
                // Transitioned to a new predefined state
                console.log(`Transitioned to state '${stateName}':`, stateConditions);
              }else {
               //console.log(`same state: Transitioned to state '${stateName}':`, stateConditions + "_currentStateName == stateName" + " transition not required.");
              }
              break; // Apply only the first matching state
            }
          }
        }
      };
    })();

    // Initialize MiniState with predefined states
    MiniState.init({
      "SIDEBAR_HIDDEN": {
        "toggleButton.value": "false",
        "loadDataButton.value": "false"
      },
      "SIDEBAR_VISIBLE": {
        "toggleButton.value": "true",
        "loadDataButton.value": "false"
      },
      "DATA_LOAD_INITIATED": {
        "loadDataButton.value": "true"
      }
    });
  </script>
</head>
<body class="flex flex-col items-center justify-center min-h-screen bg-gray-100">

  <!-- Sidebar Component -->
  <div id="sidebarComponent" class="bg-neutral w-64 h-full fixed top-0 left-0 flex flex-col justify-between transition-transform duration-300 ease-in-out z-10 hidden">
    <!-- Sidebar content -->
    <div class="h-16 flex items-center justify-between px-4">
      <button class="toggleSidebarButton text-accent" aria-label="Toggle Sidebar">â˜°</button>
    </div>

    <nav class="flex-1 p-4">
      <ul class="menu w-full">
        <li>Sidebar Entry</li>
      </ul>
    </nav>

    <script>
      // Sidebar Component Script

      // Watch for changes in 'toggleButton.value'
      MiniState.watch("toggleButton", "value", (newValue) => {
        // Based on the new value, update the sidebar's classList
        if (newValue === "true") {
          // Remove 'hidden' class to show the sidebar
          MiniState.requestLocalStateChange("sidebarComponent", "classList", "bg-neutral w-64 h-full fixed top-0 left-0 flex flex-col justify-between transition-transform duration-300 ease-in-out z-10");
        } else {
          // Add 'hidden' class to hide the sidebar
          MiniState.requestLocalStateChange("sidebarComponent", "classList", "bg-neutral w-64 h-full fixed top-0 left-0 flex flex-col justify-between transition-transform duration-300 ease-in-out z-10 hidden");
        }
      });
    </script>
  </div>

  <!-- Button Component -->
  <div id="buttonComponent" class="flex flex-col justify-center items-center w-full h-full">
    <button id="toggleButton" class="btn btn-primary mb-4">Show Sidebar</button>

    <script>
      // Button Component Script

      // Initialize the 'value' state of toggleButton to 'false'
      MiniState.requestLocalStateChange("toggleButton", "value", "false");

      // Watch for click events on the toggleButton
      MiniState.watch("toggleButton", "click", () => {
        // Toggle the 'value' state of toggleButton
        MiniState.requestLocalStateChange("toggleButton", "value", "toggle");
      });

      // Watch for changes in its own 'value' to update the button text
      MiniState.watch("toggleButton", "value", (newValue) => {
        const buttonText = newValue === "true" ? "Hide Sidebar" : "Show Sidebar";
        MiniState.requestLocalStateChange("toggleButton", "textContent", buttonText);
      });
    </script>
  </div>

  <!-- Example Component for Declarative Fetch Operation -->
  <div id="exampleComponent" class="p-4 bg-white rounded shadow mt-8">
    <!-- Content will be loaded asynchronously -->
    <p id="exampleText">Click the button to load data.</p>
    <button id="loadDataButton" class="btn btn-primary mt-2">Load Data</button>

    <script>
      // Example Component Script

      // Allowed URL for fetch operation (for security)
      const allowedUrl = 'https://jsonplaceholder.typicode.com/todos/1';

      // Initialize the 'value' state of loadDataButton to 'false'
      MiniState.requestLocalStateChange("loadDataButton", "value", "false");

      // Watch for click events on the loadDataButton
      MiniState.watch("loadDataButton", "click", () => {
        // Set the 'value' state to 'true' to initiate the predefined state transition
        MiniState.requestLocalStateChange("loadDataButton", "value", "true");
      });

      // Watch for changes in 'loadDataButton.value' to perform the fetch operation
      MiniState.watch("loadDataButton", "value", async (newValue) => {
        if (newValue === "true") {
          // Update the text to indicate loading
          MiniState.requestLocalStateChange("exampleText", "textContent", "Loading...");

          try {
            const response = await fetch(allowedUrl);
            const data = await response.json();
            // Update the text with the fetched data
            MiniState.requestLocalStateChange("exampleText", "textContent", data.title);
          } catch (error) {
            MiniState.requestLocalStateChange("exampleText", "textContent", "Error loading data");
          } finally {
            // Reset the 'value' state to 'false' after operation
            MiniState.requestLocalStateChange("loadDataButton", "value", "false");
          }
        }
      });
    </script>
  </div>

</body>
</html>
